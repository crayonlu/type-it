### 我嘞个，今天面试被拷打了，必须使使劲再学一遍JS了，但是好像看视频学习不是一个好方法，所以这次看文档，以下内容都是我觉得有必要记录下的，不一定完整
---------------
#### 类型转换
##### 以下表达式的值是什么？
```js
1. "" + 1 + 0
2. "" - 1 + 0
3. true + false
4. 6 / "3"
5. "2" * "3"
6. 4 + 5 + "px"
7. "$" + 4 + 5
8. "4" - 2
9. "4px" - 2
10. "  -9  " + 5
11. "  -9  " - 5
12. null + 1
13. undefined + 1
14. " \t \n" - 2
```
+ `""`在表达式的最开头，以后的数字都会被认为是字符串，最后结果是`" 10"`
+ 这里出现了`-`，不能用上一个题的方法，这里被看作是数字运算，结果是`-1`
+ 这里布尔值被转成`number`类型计算，最后结果是`1`
+ `2`
+ `6`
+ 这个题目区别于第一个题目，这里的计算方法是先算`4+5=9`，之后再把`9`转成字符串，最后结果就是`9px`
+ `"$45"`
+ `2`
+ `NaN`
+ ` -9 5`
+ `-14`
+ `1`
+ `NaN`原因是`undefined`在数字转换后变为`NaN`
+ `-2`
#### 严格模式
##### `use strict`
+ 写在js代码的顶部，类和模块自动启用严格模式
###### 变量声明和赋值
```
// 没有开启`use strict`的赋值
num=666;
console.log(a);
// 这样会输出666，没有报错
```
```
// 开启`use strict`
"use strict";
num = 666; // error: num is not defined
```
#### 数据类型
##### `number`
* 除了常规数字外，还有所谓的“特殊数值”也属于此数据类型：`Infinity`，`-Infinity`和`NaN`
* `NaN`表示计算错误。它是由于不正确或未定义的数学运算而导致的
* `NaN是`粘性的。对`NaN`进行任何进一步的数学运算都会返回`NaN`
* 因此，如果数学表达式中的某个地方出现`NaN` ，它会传播到整个结果（只有一个例外：`NaN ** 0`是1）
* `1/0=Infinity`
##### `BigInt`
* 在 JavaScript 中，`number`类型无法`安全`地表示大于`(2**53 -1)`的整数值（即`9007199254740991`），或者小于`-(2**53 -1)`的负数。
* 确切地说，`number`类型可以存储更大的整数（最大可达`1.7976931348623157 * 10**308` ），但超出安全整数范围`±(2**53-1)`时会出现精度错误，因为并非所有数字都适合固定的 64 位存储空间。因此可能会存储“近似”值。
```
console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
//所以说，所有大于(2**53 -1)的奇数根本不能存储在“数字”类型中
```
* 通过将`n`附加到整数末尾来创建`BigInt`值：
```
const bigInt = 1234567890123456789012345678901234567890n;
```
##### `null`
* 它形成一个单独的类型，其中只包含`null`值
* 在 `JavaScript` 中， `null`不是像其他一些语言中那样的“对不存在对象的引用”或“空指针”。
* 它只是一个代表“无”，“空”或“值未知”的特殊值。
* 通常，人们使用`null`为变量分配“空”或“未知”值，而`undefined`则保留为未分配事物的默认初始值。
##### 特殊的
```
typeof Math // "object"  (1)

typeof null // "object"  (2)

```
* `Math`是一个提供数学运算的内置对象。
* `typeof null`的结果是"object" 。这是`typeof`中官方认可的错误，源自` JavaScript `的早期版本，并为了兼容性而保留。当然，`null`不是对象。它是一个具有独立类型的特殊值。`typeof`行为在这里是错误的。
##### JavaScript 中有 8 种基本数据类型。
###### 七种原始数据类型：
* number表示任何类型的数字：整数或浮点数，整数受±(2 53 -1)的限制。
* bigint表示任意长度的整数。
* string表示字符串。字符串可能有零个或多个字符，没有单独的单字符类型。
* boolean ，表示true / false 。
* 未知值为null —— 具有单一值null的独立类型。
* undefined表示未分配的值——具有单个值undefined独立类型。
* 唯一标识符的symbol 。
###### 还有一种非原始数据类型：
* 适用于更复杂的数据结构的object 。

`typeof`运算符允许我们看到变量中存储的是哪种类型。

通常用作`typeof x` ，但`typeof(x)`也是可以的。
返回具有类型名称的字符串，如"string" 。
对于`null`返回"object" ——这是语言中的错误，它实际上不是一个对象。
#### 条件分支
###### 会显示`alert`吗？
```
if ("0") {
  alert( 'Hello' );
}
```
* 会，除空字符串（并且"0"不为空）之外的任何字符串在逻辑上下文中都变为`true` 
#### 逻辑运算符
###### `&&`and`||`
* `&&`运算符的优先级高于`||`
* 下面的代码将输出什么？
```
alert( alert(1) || 2 || alert(3) );
```
* 答案：先`1` ，然后`2`
* 对`alert`的调用没有返回值。或者换句话说，它返回`undefined`
* 之后寻找到下一个真值`2`
###### 空值合并运算符 `??`
* `a??b`的结果是:如果a有定义，那么a，如果a未定义，则b
* 换句话说，如果第一个参数不为`null/undefined` ，`??`将返回第一个参数。否则，返回第二个参数。
* 空值合并运算符`??`只是最近才被添加到 `JavaScript` 中，原因是人们对`||`不太满意
* 它们之间的重要区别是：
* `??`返回第一个定义的值。
* `||`返回第一个真值。
* 换句话说， `||`不区分`false` 、 `0` 、空字符串`""`和`null/undefined` 。它们都是相同的假值。如果其中任何一个是`||`的第一个参数，那么我们将得到第二个参数作为结果。
* 但实际上，我们可能仅当变量为`null/undefined`时才使用默认值。也就是说，当值确实未知/未设置时。
* `??`运算符的优先级与`||`相同
* 出于安全原因，`JavaScript` 禁止将`??`与`&&`和`||`运算符一起使用，除非使用括号明确指定优先级。
```
let x = 1 && 2 ?? 3; // Syntax error
let x = (1 && 2) ?? 3; // Works
```